---
title: 理解算法时间和空间复杂度
date: 2018-04-05 23:36:21
tags:
	- 算法复杂度
---

原文出自：https://blog.csdn.net/yangwei282367751/article/details/52426911

相信学习编程的同学，或多或少都接触到算法的时间复杂度和空间复杂度了，那我来讲讲怎么计算。

### 0x01、计算时间复杂度基本步骤

**1 、找出算法中的基本语句；**

　　算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。

**2、 计算基本语句的执行次数的数量级；**

　　只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。

**3、 用大O记号表示算法的时间性能。**

<!--more-->

　　将基本语句执行次数的数量级放入大O记号中。

　　如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：

```
for (i=1; i<=n; i++)
　　x++;
for (i=1; i<=n; i++)
　for (j=1; j<=n; j++)
　　x++;
```

第一个for循环的时间复杂度为O(n)，第二个for循环的时间复杂度为O(n2)，则整个算法的时间复杂度为O(n+n2)=O(n2)。

常见的算法时间复杂度**由小到大**依次为：

　　**O(1)＜O(log2n)＜O(n)＜O(nlog2n)＜O(n2)＜O(n3)＜…＜O(2n)＜O(n!)**

Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是O(1)。O(log2n)、O(n)、O(nlog2n)、O(n2)和O(n3)称为多项式时间，而O(2n)和O(n!)称为指数时间。计算机科学家普遍认为前者是有效算法，把这类问题称为P（Polynomial,多项式）类问题，而把后者称为NP（Non-Deterministic Polynomial,非确定多项式）问题。

### 0x02、计算算法时间复杂度简单的程序**分析法则**:

**1、**对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间 
**2、**对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下"求和法则" 求和法则:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n),g(n)))。特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m)+g(n)) 
**3、**对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间 
**4、**对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下"乘法法则" 
乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1*T2=O(f(n)*g(n)) 
**5、**对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度 
   另外还有以下2个运算法则:(1) 若g(n)=O(f(n)),则O(f(n))+O(g(n))=O(f(n))；(2)O(Cf(n)) = O(f(n)),其中C是一个正常数。

### **0x03、几个常见的时间复杂度进行示例说明：**

**(1)、O(1)** 

 `Temp=i; i=j; j=temp;`                     
   以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 

**（2)、O(n2)**

交换i和j的内容

```
1.sum=0；（一次）   

2.for(i=1;i<=n;i++) （n+1次）   

3.for(j=1;j<=n;j++)（n（n+1）次）   

4.sum++；（n（n+1）+1次） 

```

因为(2n2+n+1)=n2（即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(n2)；

一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。

(3)、O(n)  

```
a=0;   
b=1;                 
for (i=1;i<=n;i++){
	s=a+b;            
	b=a;                 
	a=s; 
}             
```

语句1的频度为2,语句2的频度为n,语句3的频度为n-1,语句4的频度为n-1,语句5的频度为n-1, 即T(n)=2+n+3(n-1)=4n-1=O(n). 

(4)、O(log2n) 

```
i=1;  
while (i<=n)   
i=i*2;
```

语句1的频度是1,设语句2的频度是f(n),则：2^f(n)<=n;f(n)<=log2n，取最大值f(n)=log2n,即T(n)=O(log2n) 

(5)、O(n3)  

```
for(i=0;i<n;i++){     
	for(j=0;j<i;j++){   
		for(k=0;k<j;k++)   
			x=x+2;
     }
}
```

当i=m,j=k的时候,内层循环的次数为k当i=m时, j可以取 0,1,...,m-1 ,所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n,则循环共进行了:0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n3).

### 0x04、空间复杂度

类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。 

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。

一个算法在计算机存储器上所占用的存储空间包括一下三个方面：

​	**1、存储算法本身所占用的存储空间**

​	**2、算法的输入输出数据所占用的存储空间**

​	**3、算法在运行过程中临时占用的存储空间。**

算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地"进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元。

当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。

算法的[空间复杂度](http://www.nowamagic.net/librarys/veda/tag/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)= O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。关于O(1)的问题， O(1)是说数据规模和临时变量数目无关，并不是说仅仅定义一个临时变量。举例：无论数据规模多大，我都定义100个变量，这就叫做数据规模和临时变量数目无关。就是说空间复杂度是O(1)。

对于一个[算法](http://www.nowamagic.net/librarys/veda/tag/%E7%AE%97%E6%B3%95)，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。

![img](/复杂度.png)

**常用的算法的时间复杂度和空间复杂度**

**一个经验规则：其中c是一个常量，如果一个算法的复杂度为c 、 log2n 、n 、 n\*log2n ,那么这个算法时间效率比较高 ，如果是2n ,3n ,n!，那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意。        算法复杂度分析是一个很重要的问题，任何一个程序员都应该熟练掌握其概念和基本方法，而且要善于从数学层面上探寻其本质，才能准确理解其内涵。**