---
title: 树与跳表
date: 2019-03-03 11:56:41
tags:
	- 树
	- 跳表
	- SkipList
---

# 0x01、树与跳表介绍

二分查找需要把元素存储在连续的内存中，查找的速度很快，但是插入、删除操作时需要保证元素有序性而移动大量元素比较耗性能。

如果需要一个有二分查找的速度，又能快速添加和删除元素的数据结构，首先就是二叉树，但是二叉树最坏的情况下可能变成一个链表。

于是出现了平衡二叉树，根据平衡算法不同分为AVL树(平衡二叉树)，B-Tree，B+Tree(Balance)，红黑树等，但是AVL树实现起来复杂，平衡操作难以理解，这时候可以使用SkipList跳跃表结构。

<!-- more -->

# 0x02、B-Tree、B+Tree、红黑树

**平衡二叉树（AVL树）**在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差<=1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1； 

**B-Tree**结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。

一棵m阶的B-Tree有如下特性： 
1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：

![](https://pic4.zhimg.com/80/v2-b7b62aa7a283363f173a4b76b373ef43_hd.png)



**B+Tree**是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

B+Tree相对于B-Tree有几点不同：

1. 非叶子节点只存储键值信息。
2. 所有叶子节点之间都有一个链指针。
3. 数据记录都存放在叶子节点中。

将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 

![](https://pic2.zhimg.com/80/v2-335687cfff9cf3c40b2fecd53081112e_hd.png)

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。

可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：

InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。[mysql](http://lib.csdn.net/base/mysql)的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。

# 0x03、SkipList跳跃表

传统意义的单链表是一个线性结构，向有序的链表中插入一个节点需要O(n)的时间，查找操作需要O(n)的时间。

![](https://pic4.zhimg.com/80/v2-4e1a4b77950dd47c7dfdb043c5661cbc_hd.png)

使用上面一层的跳表，可以减少所需查询时间为O(n/2)，可以根据实际情况对链表进行创建多层索引。

跳表是使用空间换取时间的一个算法，使用概率均衡技术而不是强制均衡技术，对于插入和删除比传统上的平衡树算法更加搞笑。

在java中可以使用ConcurrentHashMap来实现多线程的map存取，如果实现多线程有序map存取可以使用ConcurrentSkipList来实现。

[漫画：什么是跳跃表？](<https://mp.weixin.qq.com/s/RDHebf6IfLWfw38dPvfiZQ>)



# 0x04、参考链接

[跳表（SkipList）及ConcurrentSkipListMap源码解析](<https://blog.csdn.net/sunxianghuang/article/details/52221913>)

[MySQL中B+Tree索引原理](<https://blog.csdn.net/ifollowrivers/article/details/73614549>)